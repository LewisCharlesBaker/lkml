Advanced LookML parsing
=======================
``lkml.load`` and ``lkml.dump`` provide a simple interface between LookML and Python primitive data structures. However, ``lkml.load`` discards information about comments and whitespace, making lossless modification of LookML impossible.

For example, let's say we wanted to programmatically add a description to the dimension in this snippet of LookML:

.. code-block::

    # Inventory-related dimensions here

    dimension: days_in_inventory { sql: ${TABLE}.days_in_inventory ;; }

If we parse this LookML with ``lkml.load``, we'll lose the comment and any information about the surrounding whitespace::

    >>> text = """
    ... # Inventory-related dimensions here
    ... 
    ... dimension: days_in_inventory { sql: ${TABLE}.days_in_inventory ;; }
    ... """

    >>> parsed = lkml.load(text)
    >>> parsed
    {'dimensions': [{'name': 'days_in_inventory', 'sql': '${TABLE}.days_in_inventory'}]} 

Writing this dictionary back to LookML with ``lkml.dump`` yields the following::

    >>> print(lkml.dump(parsed))
    dimension: days_in_inventory {
       sql: ${TABLE}.days_in_inventory ;;
    }

The comment is missing and the whitespace has been overriden by ``lkml.dump``'s opinionated formatting. If we want to preserve the exact whitespace and comments surrounding this dimension, we'll need to dive under the hood of lkml and directly modify the **parse tree**.

The parse tree
--------------
The parse tree is an `immutable` tree structure generated by lkml that holds the relevant information about the parsed LookML. Each node in the tree is either a **syntax node** (a node with **children**) or a **syntax token** (a leaf node).

.. autoclass:: lkml.tree.SyntaxNode
   :members:
   :noindex:

.. autoclass:: lkml.tree.SyntaxToken
   :noindex:

You can think of syntax tokens as the fundamental pieces of text that make up LookML. Whitespace and comments are collectively referred to as **trivia** and are stored in syntax tokens in the **prefix** and **suffix** attributes.

For example, lkml represents ``hidden: yes`` as a ``PairNode``, a subclass of ``SyntaxNode``. A ``PairNode`` has two attributes, ``type`` and ``value``---each represented by ``SyntaxTokens``.

You'll notice the ``PairNode`` also stores a special kind of ``SyntaxToken`` to represent the colon ":" between the type and the value.

.. autoclass:: lkml.tree.PairNode
   :noindex:

Traversing and modifying the parse tree
---------------------------------------
aaa

Generate LookML from the parse tree
-----------------------------------
Generating LookML from the parse tree is simple because each node class defines its own ``__str__`` method to serialize its contents. To generate a LookML string from any part of the tree, just cast it with ``str``::

    tree: DocumentNode
    str(tree)